{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"SQL注入笔记","slug":"SQL注入笔记","date":"2025-02-12T08:11:29.000Z","updated":"2025-02-12T13:02:53.886Z","comments":true,"path":"2025/02/12/SQL注入笔记/","permalink":"http://example.com/2025/02/12/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/","excerpt":"","text":"SQL注入（SQL Injection）是一种常见的Web安全漏洞，形成的主要原因是web应用程序在接收相关数据参数时未做好过滤，将其直接带入到数据库中查询，导致攻击者可以拼接执行构造的SQL语句。 数字型语句：select * from table where id &#x3D;3 字符型语句：select * from table where name&#x3D;’admin’ 漏洞产生原因 没有对输入框进行限制 直接使用url传递变量 未过滤特殊字符 sql错误回显 攻击方式UNION query SQL injection（联合查询注入）联合查询适合于有显示位的注入，即页面某个位置会根据我们输入的数据的变化而变化，有注入点时页面会根据输入的数据变化而变化，当存在注入点时，优先考虑使用联合注入手法。?id=-1&#39; union select 1,2,database() --+?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ Error-based SQL injection（报错注入） 报错注入用在数据库的错误信息会回显在网页中的情况，如果联合查询不能使用，首选报错注入。 报错注入利用的是数据库的报错信息得到数据库的内容，这里需要构造语句让数据库报错。 group by 重复键冲and (select 1 from (select count(*),concat((select 查询的内容 from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) --+ extractvalue() 函数?id=1&#39; and extractvalue(1,concat(&#39;^&#39;,(select database()),&#39;^&#39;)) --+ updatexml() 函数and updatexml(1,concat(&#39;^&#39;,(需要查询的内容),&#39;^&#39;),1) 2. Boolean-based blind SQL injection（基于布尔的盲注）布尔盲注，即在页面没有错误回显时完成的注入攻击。此时我们输入的语句让页面呈现出两种状态，相当于true和false，根据这两种状态可以判断我们输入的语句是否查询成功。!（一般布尔盲注，手工去注入过于繁琐，不建议手工注入，可以借助于工具。） 布尔盲注顺序判断当前数据库类型 MySQL SQLServer access 判断数据库名 数据库名长度 数据库名每个ascii值 判断数据库的表名 数据库表的个数 每个表名的长度 每个表名的ascii 判断表中的字段名 字段个数 每个字段名长度 字段名的ascii 爆字段中的数据 字段中数据的长度 数据的ascii 判断数据库类型（哪个页面正常显示，就属于哪个数据库）MySQL数据库表(information_schema.tables)?id=1&#39; and exists(select*from information_schema.tables)######access(msysobjects) ?id=1&#39; and exists(select*from msysobjects)#####SQLServer(sysobjects)?id=1&#39; and exists(select*from sysobjects) 3. Time-based blind SQL injection（基于时间的盲注）也叫延时注入。通过观察页面，既没有回显数据库内容，又没有报错信息也没有布尔类型状态，那么我们可以考虑用“绝招”–延时注入。延时注入就是将页面的时间线作为判断依据，一点一点注入出数据库的信息。观察请求的时间线，大概在5秒以上，说明构造的sleep(5) 语句起作用，可以把这个时间线作为sql 注入的判断依据。?id=1&#39; and sleep(5) --+ （HTTP头注入）常见的sql注入一般是通过请求参数或者表单进行注入，而HTTP头部注入是通过HTTP协议头部字段值进行注入。 User-Agent使得服务器能够识别客户使用的操作系统，浏览器版本等。（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等然后将其存入数据库中）。这里获取User-Agent就可以知道客户都是通过什么浏览器访问系统的，然后将其值保存到数据库中。 cookie服务器端用来记录客户端的状态。由服务端产生，保存在浏览器中。 referer是HTTP header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。 X-forwarded-For用来识别客户端最原始的ip地址。 宽字节注入 宽字节注入准确来说不是注入手法，而是另外一种比较特殊的情况。若提交的符号被转义成其他字符。此时，转义后的字符会被作为普通字符带入数据库查询。也就是说，我们提交的单引号不会影响到原来SQL语句的结构。 宽字节是指多个字节宽度的编码，GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。转义函数在对这些编码进行转义时会将转义字符 ‘\\’ 转为 %5c ,于是我们在他前面输入一个单字符编码与它组成一个新的多字符编码，使得原本的转义字符没有发生作用。 关于编码 某字符的大小为一个字节时，称其字符为窄字节. 当某字符的大小为两个字节时，称其字符为宽字节. 所有英文默认占一个字节，汉字占两个字节 常见的宽字节编码：GB2312,GBK,GB18030,BIG5,Shift_JIS等等 黑盒如注入点后面加%df，然后按照正常的注入流程开始注入即可。如果我们需要使用sqlmap进行检测注入的话也需要在注入点后面加%df然后再用sqlmap跑 白盒查看mysql是否为GBK编码，且是否使用preg_replace()把单引号转换成\\&#39;或自带函数addslashes()进行转义 4. Stacked queries SQL injection（堆叠查询SQL注入） 堆叠查询也叫堆叠注入，在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。id=1&#39;;update users set password=&#39;123456&#39; where id=1; --+ 堆叠查询的局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。如上面的实例如果我们不输出密码那我们是看不到这个结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息 二阶注入二次注入漏洞是一种在Web应用程序中广泛存在的安全漏洞形式。相对于一次注入漏洞而言，二次注入漏洞更难以被发现，但是它却具有与—次注入攻击漏洞相同的攻击威力。1.黑客通过构造数据的形式，在浏览器或者其他软件中提交HTTP数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的SQL语句或者命令。2.服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。3.黑客向服务端发送第二个与第一次不相同的请求数据信息。4.服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的SQL语句或者命令在服务端环境中执行。5.服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功二次注入就是由于将数据存储进数据库中时未做好过滤，先提交构造好的特殊字符请求存储进数据库，然后提交第二次请求时与第一次提交进数据库中的字符发生了作用，形成了一条新的sql语句导致被执行 常用词汇 select 查询 table 表 from 来自 union 联合查询 order by ‘n’ 查询回显位 sheep 睡眠 version() 版本 @@version_compile_os 操作系统版本 database() 数据库名 @@datadir 数据库路径","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"XSS(跨站脚本)笔记","slug":"XSS(跨站脚本)笔记","date":"2025-02-12T08:11:29.000Z","updated":"2025-02-12T13:04:28.614Z","comments":true,"path":"2025/02/12/XSS(跨站脚本)笔记/","permalink":"http://example.com/2025/02/12/XSS(%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC)%E7%AC%94%E8%AE%B0/","excerpt":"","text":"XSS又叫CSS（Cross Site Script）跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）诱使受害者打开受到攻击的服务器URL。受害者在Web浏览器中打开URL，恶意脚本执行。 攻击类型反射型XSS&lt;非持久化&gt; 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。一般是后端代码进行处理 存储型XSS&lt;持久化&gt;代码是存储在服务器数据库中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。 DOM型XSS基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。一般是浏览器前端代码进行处理。 危害1.挂马2.盗取用户Cookie。3.DOS（拒绝服务）客户端浏览器。4.钓鱼攻击，高级的钓鱼技巧。5.删除目标文章、恶意篡改数据、嫁祸。6.劫持用户Web行为，甚至进一步渗透内网。7.爆发Web2.0蠕虫。8.蠕虫式的DDoS攻击。9.蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据 XSS攻击常见标签与属性1.scirpt 标签（&lt;script&gt;标签用于定义客户端脚本，比如JavaScript）&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt; 2.img 标签（&lt;img&gt;标签定义 HTML 页面中的图像）&lt;img src=1 onerror=alert(1);&gt;&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt; 3.input 标签(&lt;input&gt; 标签规定了用户可以在其中输入数据的输入字段。)onfocus 事件在对象获得焦点时发生：&lt;input onfocus=alert(1);&gt;&lt;input onblur=alert(1) autofocus&gt;&lt;input autofocus&gt;&quot; οnclick=alert(1)&gt; 这样需要点击一下输入框&lt;br&gt;&quot; onmouseover=alert(1)&gt; 需要鼠标划过输入框&lt;br&gt; 4.details 标签(&lt;details&gt; 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。ontoggle 事件规定了在用户打开或关闭 &lt;details&gt; 元素时触发)使用details 标签的 open 属性触发ontoggle事件，无需用户去点击即可触发&lt;details ontoggle=alert(1);&gt;&lt;details open ontoggle=alert(1);&gt;","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-02-12T06:37:59.120Z","updated":"2025-02-12T06:37:59.120Z","comments":true,"path":"2025/02/12/hello-world/","permalink":"http://example.com/2025/02/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"}]}